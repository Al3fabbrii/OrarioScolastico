# -*- coding: utf-8 -*-
"""ProgettoOrario.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13krqTt0kEcwJ0zxq-TLu9X2O4WErKjTl

## 1) Fase di importazione delle librerie
"""

import pandas as pd
import numpy as np
import random
import copy
import time
from collections import defaultdict, Counter

"""## 2) Definizione del problema"""

# Definizione dei set del problema
GIORNI = ["Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
SLOTS = [1, 2, 3, 4, 5]  # 5 slot giornalieri
MAX_ORE_GIORNO = 4  # Numero massimo di ore giornaliere per un professore
MAX_ORE_BUCHE = 1  # Numero massimo di ore buche per un professore in un giorno

# Lista delle classi (utilizzando l'elenco fornito)
CLASSI = ["3A", "3B", "4A", "4C", "5B", "5C"]

"""## 3) Funzione per la lettura delle cattedre ed elenco cattedre

"""

# Funzione per leggere le cattedre dei professori da un file o una stringa
def leggi_cattedre(dati_cattedre):
    cattedre = {}

    # Parsing dei dati delle cattedre
    lines = dati_cattedre.strip().split('\n')
    for line in lines:
        if not line.strip() or ':' not in line:
            continue

        parts = line.split(':')
        professore = parts[0].strip()
        assignments = parts[1].strip()

        cattedre[professore] = []

        # Estrazione delle assegnazioni per il professore
        for assignment in assignments.split(','):
            assignment = assignment.strip()
            if not assignment:
                continue

            parts = assignment.split('in')
            if len(parts) != 2:
                continue

            ore = int(parts[0].strip().split()[0])
            classe = parts[1].strip()

            cattedre[professore].append((classe, ore))

    return cattedre

# Esempio di dati delle cattedre
# Esempio di dati delle cattedre (versione con nomi casuali)
dati_cattedre = """
Smith: 3 ore in 3B, 3 ore in 5C
Johnson: 4 ore in 3A
Williams: 2 ore in 3A
Brown: 3 ore in 4C
Jones: 7 ore in 4C
Miller: 2 ore in 5B
Davis: 2 ore in 5C
Garcia: 3 ore in 4A
Martinez: 4 ore in 4C
Taylor: 2 ore in 3B, 2 ore in 5B
Anderson: 2 ore in 4C
Thomas: 3 ore in 3A
Jackson: 2 ore in 4A
White: 2 ore in 5B, 2 ore in 4C
Harris: 4 ore in 3A
Martin: 2 ore in 3B, 2 ore in 4A, 2 ore in 5C
Thompson: 2 ore in 4C
Moore: 2 ore in 3A
Allen: 6 ore in 4C
Young: 7 ore in 3B, 7 ore in 4A
King: 1 ore in 3A, 1 ore in 5B
Wright: 7 ore in 5C
Lopez: 4 ore in 4A, 4 ore in 3B
Hill: 4 ore in 5C
Scott: 2 ore in 3A
Green: 2 ore in 3B, 2 ore in 5B, 2 ore in 4A, 2 ore in 5C
Adams: 4 ore in 4A
Baker: 6 ore in 4A
Gonzalez: 5 ore in 3A, 6 ore in 5C
Nelson: 6 ore in 3B, 6 ore in 5B
Carter: 4 ore in 4C, 4 ore in 5C
Mitchell: 7 ore in 3A, 7 ore in 5B
Perez: 4 ore in 5B
Roberts: 4 ore in 3B, 4 ore in 5B
"""

"""## 4) Funzione generatrice di giorni liberi"""

def genera_preferenze_giorni_liberi(professori, giorni):
    """
    Genera preferenze per i giorni liberi:
    - Prima scelta: peso 2
    - Seconda scelta: peso 1
    - Altre scelte: peso 0
    """
    preferenze = {}

    # Esempio specifico di preferenze (generato manualmente)
    esempio_preferenze = {
    'Smith': {'Lunedì': 2, 'Mercoledì': 1, 'Martedì': 0, 'Giovedì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Johnson': {'Venerdì': 2, 'Sabato': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Giovedì': 0},
    'Williams': {'Sabato': 2, 'Lunedì': 1, 'Martedì': 0, 'Mercoledì': 0, 'Giovedì': 0, 'Venerdì': 0},
    'Brown': {'Giovedì': 2, 'Venerdì': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Sabato': 0},
    'Jones': {'Lunedì': 2, 'Giovedì': 1, 'Martedì': 0, 'Mercoledì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Miller': {'Martedì': 2, 'Sabato': 1, 'Lunedì': 0, 'Mercoledì': 0, 'Giovedì': 0, 'Venerdì': 0},
    'Davis': {'Mercoledì': 2, 'Martedì': 1, 'Lunedì': 0, 'Giovedì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Garcia': {'Sabato': 2, 'Venerdì': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Giovedì': 0},
    'Martinez': {'Giovedì': 2, 'Venerdì': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Sabato': 0},
    'Taylor': {'Lunedì': 2, 'Venerdì': 1, 'Martedì': 0, 'Mercoledì': 0, 'Giovedì': 0, 'Sabato': 0},
    'Anderson': {'Martedì': 2, 'Giovedì': 1, 'Lunedì': 0, 'Mercoledì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Thomas': {'Giovedì': 2, 'Sabato': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Venerdì': 0},
    'Jackson': {'Mercoledì': 2, 'Lunedì': 1, 'Martedì': 0, 'Giovedì': 0, 'Venerdì': 0, 'Sabato': 0},
    'White': {'Venerdì': 2, 'Mercoledì': 1, 'Lunedì': 0, 'Martedì': 0, 'Giovedì': 0, 'Sabato': 0},
    'Harris': {'Sabato': 2, 'Giovedì': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Venerdì': 0},
    'Martin': {'Mercoledì': 2, 'Venerdì': 1, 'Lunedì': 0, 'Martedì': 0, 'Giovedì': 0, 'Sabato': 0},
    'Thompson': {'Lunedì': 2, 'Mercoledì': 1, 'Martedì': 0, 'Giovedì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Moore': {'Martedì': 2, 'Lunedì': 1, 'Mercoledì': 0, 'Giovedì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Allen': {'Giovedì': 2, 'Martedì': 1, 'Lunedì': 0, 'Mercoledì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Young': {'Sabato': 2, 'Mercoledì': 1, 'Lunedì': 0, 'Martedì': 0, 'Giovedì': 0, 'Venerdì': 0},
    'King': {'Venerdì': 2, 'Sabato': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Giovedì': 0},
    'Wright': {'Lunedì': 2, 'Sabato': 1, 'Martedì': 0, 'Mercoledì': 0, 'Giovedì': 0, 'Venerdì': 0},
    'Lopez': {'Martedì': 2, 'Venerdì': 1, 'Lunedì': 0, 'Mercoledì': 0, 'Giovedì': 0, 'Sabato': 0},
    'Hill': {'Mercoledì': 2, 'Giovedì': 1, 'Lunedì': 0, 'Martedì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Scott': {'Giovedì': 2, 'Lunedì': 1, 'Martedì': 0, 'Mercoledì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Green': {'Venerdì': 2, 'Mercoledì': 1, 'Lunedì': 0, 'Martedì': 0, 'Giovedì': 0, 'Sabato': 0},
    'Adams': {'Sabato': 2, 'Martedì': 1, 'Lunedì': 0, 'Mercoledì': 0, 'Giovedì': 0, 'Venerdì': 0},
    'Baker': {'Lunedì': 2, 'Giovedì': 1, 'Martedì': 0, 'Mercoledì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Gonzalez': {'Martedì': 2, 'Lunedì': 1, 'Mercoledì': 0, 'Giovedì': 0, 'Venerdì': 0, 'Sabato': 0},
    'Nelson': {'Mercoledì': 2, 'Sabato': 1, 'Lunedì': 0, 'Martedì': 0, 'Giovedì': 0, 'Venerdì': 0},
    'Carter': {'Giovedì': 2, 'Venerdì': 1, 'Lunedì': 0, 'Martedì': 0, 'Mercoledì': 0, 'Sabato': 0},
    'Mitchell': {'Venerdì': 2, 'Martedì': 1, 'Lunedì': 0, 'Mercoledì': 0, 'Giovedì': 0, 'Sabato': 0},
    'Perez': {'Sabato': 2, 'Mercoledì': 1, 'Lunedì': 0, 'Martedì': 0, 'Giovedì': 0, 'Venerdì': 0},
    'Roberts': {'Mercoledì': 2, 'Sabato': 1, 'Lunedì': 0, 'Martedì': 0, 'Giovedì': 0, 'Venerdì': 0},
    }

    # Per ogni professore, prendi le preferenze dall'esempio o genera casualmente se non presenti
    for prof in professori:
        if prof in esempio_preferenze:
            preferenze[prof] = esempio_preferenze[prof]
        else:
            # Per eventuali professori non presenti nell'esempio, genera casualmente
            prima_scelta, seconda_scelta = random.sample(giorni, 2)
            prof_pref = {g: 0 for g in giorni}
            prof_pref[prima_scelta] = 2   # Prima scelta (peso 2)
            prof_pref[seconda_scelta] = 1  # Seconda scelta (peso 1)
            preferenze[prof] = prof_pref

    return preferenze

"""## 5) Funzione per il calcolo del punteggio di un assegnamento"""

def calcola_punteggio(prof, classe, giorno, slot, orario_attuale, cattedre_rimanenti, preferenze_giorni, fase_di_riempimento=False):
    punteggio = 0

    # Verifica se il professore può insegnare in questa classe
    if classe not in [c for c, _ in cattedre_rimanenti.get(prof, [])]:
        return float('-inf')  # Impossibile assegnare

    # Verifica ore massime giornaliere
    ore_prof_giorno = sum(1 for g, s, p, c in orario_attuale if p == prof and g == giorno)
    if ore_prof_giorno >= MAX_ORE_GIORNO:
        return float('-inf')  # Superato il limite di ore giornaliere

    # Verifica sovrapposizioni (stesso slot, stesso giorno per prof o classe)
    for g, s, p, c in orario_attuale:
        if g == giorno and s == slot:
            if p == prof or c == classe:
                return float('-inf')  # Sovrapposizione trovata

    # Verifica lezioni dello stesso prof nella stessa classe nello stesso giorno
    lezioni_stessa_classe = sum(1 for g, s, p, c in orario_attuale
                             if g == giorno and p == prof and c == classe)
    if lezioni_stessa_classe >= 2:  # Massimo 2 lezioni per classe al giorno
        return float('-inf')  # Nella fase normale, rispettiamo strettamente il vincolo

    # Calcola ore buche potenziali
    slots_occupati = [s for g, s, p, c in orario_attuale if g == giorno and p == prof]
    slots_occupati.append(slot)
    slots_occupati.sort()

    ore_buche = ha_ore_buche(slots_occupati)
    if ore_buche > MAX_ORE_BUCHE:
      return float('-inf')  # Troppi buchi nella fase normale

    # Verifica vincolo sulle lezioni distanziate
    if not verifica_sequenza_lezioni(prof, classe, giorno, slot, orario_attuale) and not fase_di_riempimento:
        return float('-inf')  # Viola il vincolo sulla sequenza di lezioni

    # Premia l'assegnazione di più ore di un professore nella stessa classe nello stesso giorno
    # (ma non più di due volte al giorno per classe)
    if lezioni_stessa_classe == 1:
        punteggio += 50  # Incentiva l'accorpamento di lezioni della stessa materia

    # Considera le preferenze per i giorni liberi
    # Penalizza l'assegnazione nei giorni più preferiti come liberi
    punteggio -= preferenze_giorni.get(prof, {}).get(giorno, 0) * 10

    # Premia l'assegnazione di prof con più ore rimanenti
    ore_rimanenti_totali = sum(ore for _, ore in cattedre_rimanenti.get(prof, []))
    punteggio += ore_rimanenti_totali * 0.5

    # Premia l'assegnazione di professori con meno flessibilità (meno classi assegnate)
    num_classi_prof = len(cattedre_rimanenti.get(prof, []))
    punteggio += (6 - num_classi_prof) * 5  # Più è basso il numero di classi, più alto è il bonus

    # Distribuisci più uniformemente le ore nell'arco della settimana
    ore_per_giorno = {}
    for g in GIORNI:
        ore_per_giorno[g] = sum(1 for gg, _, pp, _ in orario_attuale if pp == prof and gg == g)

    # Penalizza l'assegnazione in giorni già carichi
    punteggio -= ore_per_giorno.get(giorno, 0) * 5

    # Bilanciamento per evitare troppe lezioni consecutive
    if len(slots_occupati) >= 3:
        consecutivi = sum(1 for i in range(len(slots_occupati)-1) if slots_occupati[i+1] - slots_occupati[i] == 1)
        if consecutivi >= 3:  # Se ci sono già 3+ slot consecutivi
            punteggio -= 30  # Penalizza ulteriori slot consecutivi

    return punteggio
def ha_ore_buche(slots_occupati):
    """
    Verifica se ci sono ore buche nei slot occupati.
    Una ora buca è quando c'è un gap tra due slot occupati.
    """
    if len(slots_occupati) <= 1:
        return 0

    slots_occupati.sort()
    ore_buche = 0

    for i in range(len(slots_occupati) - 1):
        gap = slots_occupati[i + 1] - slots_occupati[i] - 1
        ore_buche += max(0, gap)  # Conta solo i gap positivi

    return ore_buche

def verifica_sequenza_lezioni(prof, classe, giorno, slot, orario_attuale):
    """
    Verifica che un professore non insegni nella stessa classe con
    lezioni distanziate di 2 slot o più
    """
    slots_occupati_classe = [s for g, s, p, c in orario_attuale
                           if g == giorno and p == prof and c == classe]

    if not slots_occupati_classe:
        return True

    # Aggiungi lo slot attuale
    slots_futuri = slots_occupati_classe + [slot]
    slots_futuri.sort()

    # Verifica se ci sono lezioni distanziate da 2 o più slot
    for i in range(len(slots_futuri) - 1):
        if slots_futuri[i+1] - slots_futuri[i] >= 3:  # distanza di 2 o più slot
            return False

    return True

"""## 6) Funzione principale dell'algoritmo greedy

"""

def orario_scolastico(cattedre, classi, giorni, slots, preferenze_giorni):
    # Inizializza l'orario vuoto
    orario = []

    # Copia delle cattedre rimanenti da assegnare
    cattedre_rimanenti = {}
    for prof, assegnazioni in cattedre.items():
        cattedre_rimanenti[prof] = assegnazioni.copy()

    # Conteggio delle ore totali da assegnare
    ore_totali = sum(ore for prof in cattedre_rimanenti for _, ore in cattedre_rimanenti[prof])
    ore_iniziali = ore_totali
    print(f"Ore totali da assegnare: {ore_totali}")

    # Dizionario per tenere traccia degli slot già assegnati
    slot_assegnati = set()

    # Dizionario per tenere traccia della saturazione (slot occupati) per ogni prof e classe
    saturazione_prof = {prof: set() for prof in cattedre.keys()}
    saturazione_classe = {classe: set() for classe in classi}

    # Finché ci sono ore da assegnare
    while ore_totali > 0:
        # Calcola il grado di saturazione per ogni combinazione (prof, classe)
        miglior_punteggio = -float('inf')
        migliore_combinazione = None
        migliore_slot = None

        for prof, assegnazioni in cattedre_rimanenti.items():
            for classe, ore in assegnazioni:
                if ore <= 0:
                    continue

                # Calcola il grado di saturazione (slot non disponibili)
                saturazione = len(saturazione_prof[prof].union(saturazione_classe[classe]))

                # Numero totale di ore da assegnare per questa combinazione
                ore_totali_combinazione = ore

                # Numero di classi assegnate al professore (meno classi = meno flessibilità)
                num_classi_prof = len(cattedre_rimanenti[prof])

                # Punteggio combinato: maggiore saturazione è meglio, più ore rimanenti è meglio,
                # meno classi assegnate è meglio (meno flessibilità)
                punteggio_combinazione = (saturazione * 1000) + (ore_totali_combinazione * 10) - num_classi_prof

                # Trova il miglior slot disponibile per questa combinazione
                for giorno in giorni:
                    for slot in slots:
                        # Verifica se lo slot è già occupato
                        if (giorno, slot, classe) in slot_assegnati or (giorno, slot, prof) in slot_assegnati:
                            continue

                        # Verifica altri vincoli
                        punteggio_slot = calcola_punteggio(prof, classe, giorno, slot, orario, cattedre_rimanenti, preferenze_giorni)

                        if punteggio_slot > float('-inf'):  # Slot ammissibile
                            punteggio_finale = punteggio_combinazione + punteggio_slot

                            if punteggio_finale > miglior_punteggio:
                                miglior_punteggio = punteggio_finale
                                migliore_combinazione = (prof, classe)
                                migliore_slot = (giorno, slot)

        # Se non è stato trovato uno slot valido, interrompi
        if migliore_combinazione is None:
            print(f"Non è possibile assegnare ulteriori ore. Rimangono {ore_totali} ore da assegnare.")
            break

        # Assegna la lezione
        prof, classe = migliore_combinazione
        giorno, slot = migliore_slot

        orario.append((giorno, slot, prof, classe))
        slot_assegnati.add((giorno, slot, classe))
        slot_assegnati.add((giorno, slot, prof))

        # Aggiorna la saturazione
        saturazione_prof[prof].add((giorno, slot))
        saturazione_classe[classe].add((giorno, slot))

        # Aggiorna le ore rimanenti
        for i, (c, o) in enumerate(cattedre_rimanenti[prof]):
            if c == classe:
                cattedre_rimanenti[prof][i] = (c, o - 1)
                break

        ore_totali -= 1

        # Aggiungi anche gli slot in cui il prof non può più insegnare
        for s in slots:
            # Se il prof ha già MAX_ORE_GIORNO ore in questo giorno
            ore_prof_giorno = sum(1 for g, _, p, _ in orario if p == prof and g == giorno)
            if ore_prof_giorno >= MAX_ORE_GIORNO:
                for s2 in slots:
                    saturazione_prof[prof].add((giorno, s2))

            # Verifica ore buche
            slots_occupati = [s for g, s, p, _ in orario if g == giorno and p == prof]
            if ha_ore_buche(slots_occupati) >= MAX_ORE_BUCHE:
                # Blocca slot che creerebbero ulteriori ore buche
                for s2 in slots:
                    slots_occupati_test = slots_occupati + [s2]
                    if ha_ore_buche(slots_occupati_test) > MAX_ORE_BUCHE:
                        saturazione_prof[prof].add((giorno, s2))

    # Verifica se tutte le ore sono state assegnate
    ore_assegnate = len(orario)
    if ore_assegnate < ore_iniziali:
        print(f"ATTENZIONE: Assegnate solo {ore_assegnate} ore su {ore_iniziali}!")

        # Ripristina le cattedre rimanenti in base all'orario generato
        cattedre_rimanenti = {}
        for prof, assegnazioni in cattedre.items():
            cattedre_rimanenti[prof] = []
            for classe, ore in assegnazioni:
                ore_assegnate = sum(1 for g, s, p, c in orario if p == prof and c == classe)
                ore_rimanenti = ore - ore_assegnate
                if ore_rimanenti > 0:
                    cattedre_rimanenti[prof].append((classe, ore_rimanenti))
                    print(f"  {prof}: {ore_rimanenti} ore rimanenti in {classe}")
    else:
        print(f"Tutte le {ore_iniziali} ore sono state assegnate con successo!")

    return orario

"""## 7) Funzione per visualizzare l'orario

"""

# Funzione per visualizzare l'orario generato
def visualizza_orario(orario, classi, giorni, slots):
    # Crea un DataFrame vuoto per ogni classe
    orari_per_classe = {}
    for classe in classi:
        df = pd.DataFrame(index=slots, columns=giorni)
        df.index.name = "Slot"
        orari_per_classe[classe] = df

    # Riempi i DataFrame con le assegnazioni
    for giorno, slot, prof, classe in orario:
        orari_per_classe[classe].at[slot, giorno] = prof

    return orari_per_classe

"""## 8) Fase di ricerca locale"""

def ottimizza_orario_ricerca_locale(orario_iniziale, cattedre, preferenze_giorni,
                                    max_iterazioni=2000, max_tentativi_senza_miglioramento=400):
    """
    Ottimizza l'orario usando la ricerca locale attraverso mosse di scambio e spostamento.
    """
    orario_corrente = copy.deepcopy(orario_iniziale)
    valore_corrente = calcola_valore_soluzione(orario_corrente, preferenze_giorni)

    orario_migliore = copy.deepcopy(orario_corrente)
    valore_migliore = valore_corrente

    iterazioni_senza_miglioramento = 0

    print(f"Valore iniziale della soluzione: {valore_corrente}")

    for iterazione in range(max_iterazioni):
        # Genera una nuova soluzione attraverso una mossa
        nuovo_orario = genera_mossa(orario_corrente)

        # Verifica se la nuova soluzione è ammissibile
        if verifica_ammissibilita(nuovo_orario, cattedre):
            # Calcola il valore della nuova soluzione
            nuovo_valore = calcola_valore_soluzione(nuovo_orario, preferenze_giorni)

            # Accetta la mossa se migliora la soluzione
            if nuovo_valore > valore_corrente:
                orario_corrente = nuovo_orario
                valore_corrente = nuovo_valore
                iterazioni_senza_miglioramento = 0

                # Aggiorna la miglior soluzione trovata
                if valore_corrente > valore_migliore:
                    orario_migliore = copy.deepcopy(orario_corrente)
                    valore_migliore = valore_corrente
                    print(f"Nuova miglior soluzione trovata alla iterazione {iterazione} con valore {valore_migliore}")
            else:
                iterazioni_senza_miglioramento += 1
        else:
            iterazioni_senza_miglioramento += 1

        # Criteri di terminazione
        if iterazioni_senza_miglioramento >= max_tentativi_senza_miglioramento:
            print(f"Terminazione anticipata dopo {iterazione+1} iterazioni: nessun miglioramento per {max_tentativi_senza_miglioramento} tentativi")
            break

    print(f"Ricerca locale completata. Valore finale: {valore_migliore}")
    return orario_migliore


def verifica_ammissibilita(orario, cattedre):
    """
    Verifica se una soluzione è ammissibile (rispetta i vincoli fondamentali).
    Restituisce True se la soluzione è ammissibile, False altrimenti.
    """
    # Verifica sovrapposizioni
    slot_occupati = set()
    for giorno, slot, prof, classe in orario:
        # Verifica che non ci siano sovrapposizioni di prof o classe nello stesso slot
        if (giorno, slot, prof) in slot_occupati or (giorno, slot, classe) in slot_occupati:
            return False
        slot_occupati.add((giorno, slot, prof))
        slot_occupati.add((giorno, slot, classe))

    # Verifica ore massime giornaliere
    for prof in set(p for _, _, p, _ in orario):
        for giorno in GIORNI:
            ore_prof_giorno = sum(1 for g, _, p, _ in orario if p == prof and g == giorno)
            if ore_prof_giorno > MAX_ORE_GIORNO:
                return False

    # Verifica ore totali per ogni cattedra
    ore_assegnate, _ = conta_ore_assegnate(orario, cattedre)
    for prof, assegnazioni in cattedre.items():
        for classe, ore_richieste in assegnazioni:
            ore_effettive = ore_assegnate[prof][classe]
            if ore_effettive > ore_richieste:  # Possiamo avere meno ore, ma non più
                return False

    return True
def genera_mossa(orario):
    """
    Genera una mossa casuale per la ricerca locale:
    - Scambio di slot tra due professori
    - Spostamento di una lezione a un altro giorno/slot
    """
    tipo_mossa = random.choice(["scambio", "spostamento"])

    if tipo_mossa == "scambio" and len(orario) >= 2:
        # Scegliamo due lezioni da scambiare
        idx1, idx2 = random.sample(range(len(orario)), 2)
        giorno1, slot1, prof1, classe1 = orario[idx1]
        giorno2, slot2, prof2, classe2 = orario[idx2]

        # Creiamo una copia dell'orario
        nuovo_orario = copy.deepcopy(orario)
        # Effettuiamo lo scambio
        nuovo_orario[idx1] = (giorno2, slot2, prof1, classe1)
        nuovo_orario[idx2] = (giorno1, slot1, prof2, classe2)

        return nuovo_orario
    else:
        # Spostamento di una lezione
        idx = random.randrange(len(orario))
        giorno_attuale, slot_attuale, prof, classe = orario[idx]

        # Scegli un nuovo giorno e slot
        nuovo_giorno = random.choice(GIORNI)
        nuovo_slot = random.choice(SLOTS)

        # Se è lo stesso slot, non fare nulla
        if nuovo_giorno == giorno_attuale and nuovo_slot == slot_attuale:
            return orario

        # Creiamo una copia dell'orario e aggiorniamo
        nuovo_orario = copy.deepcopy(orario)
        nuovo_orario[idx] = (nuovo_giorno, nuovo_slot, prof, classe)

        return nuovo_orario
def calcola_valore_soluzione(orario, preferenze_giorni):
    """
    Calcola il valore della soluzione in base a diversi fattori:
    - Preferenze dei giorni liberi soddisfatte
    - Numero di ore buche
    - Distribuzione delle ore
    """
    punteggio = 0

    # Calcola i giorni liberi per ogni professore
    giorni_prof = defaultdict(set)
    for giorno, _, prof, _ in orario:
        giorni_prof[prof].add(giorno)

    # Giorni liberi e soddisfazione preferenze
    for prof, giorni_occupati in giorni_prof.items():
        giorni_liberi = set(GIORNI) - giorni_occupati
        for giorno in giorni_liberi:
            punteggio += preferenze_giorni.get(prof, {}).get(giorno, 0) * 50

    # Penalizza ore buche
    for prof in set(p for _, _, p, _ in orario):
        for giorno in GIORNI:
            slots_occupati = sorted([s for g, s, p, _ in orario if g == giorno and p == prof])
            ore_buche = 0
            for i in range(len(slots_occupati) - 1):
                gap = slots_occupati[i + 1] - slots_occupati[i] - 1
                ore_buche += max(0, gap)
            punteggio -= ore_buche * 20  # Penalità per ogni ora buca

    # Premia distribuzione equa delle ore
    for prof in set(p for _, _, p, _ in orario):
        ore_per_giorno = Counter(g for g, _, p, _ in orario if p == prof)
        std_dev = np.std(list(ore_per_giorno.values())) if ore_per_giorno else 0
        punteggio -= std_dev * 10  # Penalità per distribuzione non uniforme

    # Premia continuità delle lezioni (slot consecutivi)
    for prof in set(p for _, _, p, _ in orario):
        for giorno in GIORNI:
            slots_prof = sorted([s for g, s, p, _ in orario if g == giorno and p == prof])
            for i in range(len(slots_prof) - 1):
                if slots_prof[i + 1] == slots_prof[i] + 1:  # Slot consecutivi
                    punteggio += 5  # Bonus per continuità

    return punteggio

def conta_ore_assegnate(orario, cattedre):
    """
    Conta le ore assegnate per ogni professore e classe
    e confronta con il numero richiesto.
    """
    ore_assegnate = defaultdict(lambda: defaultdict(int))
    for _, _, prof, classe in orario:
        ore_assegnate[prof][classe] += 1

    ore_mancanti = {}
    for prof, assegnazioni in cattedre.items():
        prof_ore_mancanti = {}
        for classe, ore_richieste in assegnazioni:
            assegnate = ore_assegnate[prof][classe]
            mancanti = ore_richieste - assegnate
            if mancanti > 0:
                prof_ore_mancanti[classe] = mancanti
        if prof_ore_mancanti:
            ore_mancanti[prof] = prof_ore_mancanti

    return ore_assegnate, ore_mancanti

"""## 9) Main"""

def main():
    """
    Funzione principale che esegue l'algoritmo greedy iniziale seguito da
    completamento e ottimizzazione dell'orario tramite ricerca locale.
    """

    print("FASE 1: Creazione orario iniziale...")
    orario = orario_scolastico(cattedre, CLASSI, GIORNI, SLOTS, preferenze_giorni)

    # Calcola le cattedre rimanenti
    _, ore_mancanti = conta_ore_assegnate(orario, cattedre)

    print("\nFASE 2: Completamento dell'orario")
    orario_completo = completa_orario(orario, cattedre, CLASSI, GIORNI, SLOTS)

    print("\nFASE 3: Ottimizzazione dell'orario tramite ricerca locale...")
    orario_ottimizzato = ottimizza_orario_ricerca_locale(orario_completo, cattedre, preferenze_giorni)

    # Assegna giorni liberi in base all'orario ottimizzato
    giorni_liberi_ottimizzati = assegna_giorni_liberi(orario_ottimizzato, preferenze_giorni)

    # Visualizza l'orario ottimizzato
    orari_per_classe = visualizza_orario(orario_ottimizzato, CLASSI, GIORNI, SLOTS)

    # Valutazione finale
    print("\nValutazione finale dell'orario ottimizzato:")
    valore_soluzione = calcola_valore_soluzione(orario_ottimizzato, preferenze_giorni)
    print(f"Punteggio della soluzione: {valore_soluzione}")

    slot_vuoti_rimasti = trova_slot_vuoti(orario_ottimizzato, CLASSI, GIORNI, SLOTS)
    print(f"Slot vuoti rimasti: {len(slot_vuoti_rimasti)}")

    # Statistiche sui giorni liberi
    print("\nGiorni liberi assegnati:")
    for prof, giorno in sorted(giorni_liberi_ottimizzati.items()):
        preferenza = preferenze_giorni[prof][giorno] if giorno else "N/A"
        if preferenza == 2:
            soddisfazione = "Prima scelta"
        elif preferenza == 1:
            soddisfazione = "Seconda scelta"
        else:
            soddisfazione = "Altra scelta"

        print(f"{prof}: {giorno if giorno else 'Nessun giorno libero'} ({soddisfazione})")

    print("\nStatistiche sulla soddisfazione delle preferenze:")
    prima_scelta = sum(1 for prof, giorno in giorni_liberi_ottimizzati.items()
                      if giorno and preferenze_giorni[prof][giorno] == 2)
    seconda_scelta = sum(1 for prof, giorno in giorni_liberi_ottimizzati.items()
                       if giorno and preferenze_giorni[prof][giorno] == 1)
    altra_scelta = sum(1 for prof, giorno in giorni_liberi_ottimizzati.items()) - prima_scelta - seconda_scelta


    n_professori = len(cattedre)
    print(f"Prima scelta: {prima_scelta}/{n_professori} ({prima_scelta/n_professori*100:.1f}%)")
    print(f"Seconda scelta: {seconda_scelta}/{n_professori} ({seconda_scelta/n_professori*100:.1f}%)")
    print(f"Altra scelta: {altra_scelta}/{n_professori} ({altra_scelta/n_professori*100:.1f}%)")

    return orario_ottimizzato, giorni_liberi_ottimizzati, orari_per_classe

def assegna_giorni_liberi(orario, preferenze_giorni):
    """
    Assegna giorni liberi in base all'orario generato e alle preferenze.
    """
    giorni_liberi = {}

    for prof in set(p for _, _, p, _ in orario):
        # Trova i giorni in cui il professore ha lezioni
        giorni_con_lezioni = set(giorno for giorno, _, p, _ in orario if p == prof)

        # Giorni disponibili come liberi
        giorni_disponibili = [g for g in GIORNI if g not in giorni_con_lezioni]

        if giorni_disponibili:
            # Ordina in base alle preferenze (più alto è meglio)
            giorni_disponibili.sort(key=lambda g: preferenze_giorni.get(prof, {}).get(g, 0), reverse=True)
            giorni_liberi[prof] = giorni_disponibili[0]
        else:
            # Nel caso tutti i giorni abbiano lezioni (situazione non ottimale)
            giorni_liberi[prof] = None

    return giorni_liberi

def completa_orario(orario, cattedre, classi, giorni, slots):
    """
    Completa l'orario riempiendo tutti gli slot vuoti rispettando il più possibile i vincoli.
    Se necessario, rilassa alcuni vincoli per garantire la completezza dell'orario.
    """
    orario_completo = copy.deepcopy(orario)

    # Identifica le ore mancanti per ogni professore
    _, ore_mancanti = conta_ore_assegnate(orario_completo, cattedre)

    # Identifica gli slot vuoti da riempire
    slot_vuoti = trova_slot_vuoti(orario_completo, classi, giorni, slots)

    if not slot_vuoti:
        print("L'orario è già completo!")
        return orario_completo

    print(f"Completamento orario: {len(slot_vuoti)} slot vuoti da riempire")

    # Prima fase: tentativo con vincoli rigorosi
    for giorno, slot, classe in list(slot_vuoti):
        # Troviamo professori che devono ancora insegnare in questa classe
        for prof, classi_mancanti in ore_mancanti.items():
            if classe in classi_mancanti and classi_mancanti[classe] > 0:
                # Verifica se l'assegnazione rispetta i vincoli
                if verifica_ammissibilita(orario_completo, cattedre):
                    # Assegna la lezione
                    orario_completo.append((giorno, slot, prof, classe))
                    # Aggiorna le ore mancanti
                    ore_mancanti[prof][classe] -= 1
                    if ore_mancanti[prof][classe] == 0:
                        del ore_mancanti[prof][classe]
                        if not ore_mancanti[prof]:
                            del ore_mancanti[prof]
                    slot_vuoti.remove((giorno, slot, classe))
                    break

    # Seconda fase: rilassiamo alcuni vincoli per gli slot ancora vuoti
    for giorno, slot, classe in list(slot_vuoti):
        for prof, classi_mancanti in list(ore_mancanti.items()):
            if classe in classi_mancanti and classi_mancanti[classe] > 0:
                # Verifica con vincoli rilassati
                if verifica_ammissibilita(orario_completo,cattedre):
                    orario_completo.append((giorno, slot, prof, classe))
                    ore_mancanti[prof][classe] -= 1
                    if ore_mancanti[prof][classe] == 0:
                        del ore_mancanti[prof][classe]
                        if not ore_mancanti[prof]:
                            del ore_mancanti[prof]
                    slot_vuoti.remove((giorno, slot, classe))
                    break

    print(f"Slot vuoti rimasti dopo il completamento: {len(slot_vuoti)}")
    return orario_completo


def trova_slot_vuoti(orario, classi, giorni, slots):
    """
    Identifica gli slot orari che non sono stati assegnati.
    """
    slot_vuoti = []
    for classe in classi:
        for giorno in giorni:
            for slot in slots:
                if not any(g == giorno and s == slot and c == classe for g, s, _, c in orario):
                    slot_vuoti.append((giorno, slot, classe))
    return slot_vuoti

"""## 10) Analisi dei risultati"""

# Analisi dei risultati
def analizza_risultati(orario, giorni_liberi, cattedre, preferenze_giorni):
    # Statistiche sull'orario generato
    professori = list(cattedre.keys())
    n_professori = len(professori)
    n_assegnazioni = len(orario)

    # Ore per giorno per ogni professore
    ore_per_giorno_prof = defaultdict(lambda: defaultdict(int))
    for giorno, slot, prof, classe in orario:
        ore_per_giorno_prof[prof][giorno] += 1

    # Statistiche sui giorni liberi
    giorni_liberi_count = Counter(giorni_liberi.values())

    # Statistiche sul soddisfacimento delle preferenze
    soddisfazione_preferenze = {}
    for prof, giorno in giorni_liberi.items():
        if giorno:
            # Punteggio di preferenza (più alto è meglio)
            preferenza = preferenze_giorni[prof][giorno]
            soddisfazione_preferenze[prof] = (preferenza, max(preferenze_giorni[prof].values()))

    return {
        "n_professori": n_professori,
        "n_assegnazioni": n_assegnazioni,
        "ore_per_giorno_prof": dict(ore_per_giorno_prof),
        "giorni_liberi": giorni_liberi,
        "giorni_liberi_count": dict(giorni_liberi_count),
        "soddisfazione_preferenze": soddisfazione_preferenze
    }

"""## 11) Esecuzione algoritmo e stampa delle statistiche"""

# Esegui l'algoritmo e analizza i risultati
# Elabora i dati delle cattedre
cattedre = leggi_cattedre(dati_cattedre)
# Genera preferenze per i giorni liberi
preferenze_giorni = genera_preferenze_giorni_liberi(cattedre.keys(), GIORNI)
orario, giorni_liberi, orari_per_classe = main()  # Assign to 3 variables
analisi = analizza_risultati(orario, giorni_liberi, leggi_cattedre(dati_cattedre), preferenze_giorni)  # preferenze_giorni is already defined

# Visualizza l'orario di tutte le classi
for classe in CLASSI:
    print(f"\nOrario della classe {classe}:")
    print(orari_per_classe[classe])